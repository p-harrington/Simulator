/*
 * WinPILib - Task.cpp
 * Copyright (c) 2013 Tony "untitled" Peng
 * <http://www.tonypeng.com/>,
 * Varun Parthasarathy
 * 
 * This file is subject to the terms and conditions defined in the
 * file 'LICENSE.txt', which is part of this source code package.
 */

#include "Task.h"

#include "WPIErrors.h"
#include <string.h>
#include <taskLib.h>

const UINT32 Task::kDefaultPriority;
const INT32 Task::kInvalidTaskID;

Task::Task(const char* name, FUNCPTR function, INT32 priority, UINT32 stackSize)
{
	m_taskID = kInvalidTaskID;
	m_function = function;
	m_priority = priority;
	m_stackSize = stackSize;
	m_taskName = new char[strlen(name) + 5];
	strcpy(m_taskName, "FRC_");
	strcpy(m_taskName+4, name);

	static INT32 instances = 0;
	instances++;
}

Task::~Task()
{
	if (m_taskID != kInvalidTaskID) Stop();
	delete [] m_taskName;
	m_taskName = NULL;
}

bool Task::Start(UINT32 arg0, UINT32 arg1, UINT32 arg2, UINT32 arg3, UINT32 arg4, 
		UINT32 arg5, UINT32 arg6, UINT32 arg7, UINT32 arg8, UINT32 arg9)
{
	m_taskID = taskSpawn(m_taskName, m_priority, VX_FP_TASK, m_stackSize, m_function,
						arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);

	if(!HandleError(m_taskID))
	{
		m_taskID = kInvalidTaskID;
		return false;
	}

	return true;
}

bool Task::Restart()
{
	return HandleError(taskRestart(m_taskID));
}

bool Task::Stop()
{
	bool ok = true;

	if (Verify())
	{
		ok = HandleError(taskDelete(m_taskID));
	}

	m_taskID = kInvalidTaskID;

	return ok;
}

bool Task::IsReady()
{
	return taskIsReady(m_taskID);
}

bool Task::IsSuspended()
{
	return taskIsSuspended(m_taskID);
}

bool Task::Suspend()
{
	return HandleError(taskSuspend(m_taskID));
}

bool Task::Resume()
{
	return HandleError(taskResume(m_taskID));
}

bool Task::Verify()
{
	return taskIdVerify(m_taskID) == OK;
}

INT32 Task::GetPriority()
{
	if (HandleError(taskPriorityGet(m_taskID, &m_priority)))
		return m_priority;
	else
		return 0;
}

bool Task::SetPriority(INT32 priority)
{
	m_priority = priority;
	return HandleError(taskPrioritySet(m_taskID, m_priority));
}

/**
 * Returns the name of the task.
 * @returns Pointer to the name of the task or NULL if not allocated
 */
const char* Task::GetName()
{
	return m_taskName;
}

/**
 * Get the ID of a task
 * @returns Task ID of this task.  Task::kInvalidTaskID (-1) if the task has not been started or has already exited.
 */
INT32 Task::GetID()
{
	if (Verify())
		return m_taskID;
	return kInvalidTaskID;
}

/**
 * Handles errors generated by task related code.
 */
bool Task::HandleError(STATUS results)
{
	if (results != ERROR) return true;
	//Unused
	/*switch(errnoGet())
	{
	case S_objLib_OBJ_ID_ERROR:
		wpi_setWPIErrorWithContext(TaskIDError, m_taskName);
		break;
		
	case S_objLib_OBJ_DELETED:
		wpi_setWPIErrorWithContext(TaskDeletedError, m_taskName);
		break;
		
	case S_taskLib_ILLEGAL_OPTIONS:
		wpi_setWPIErrorWithContext(TaskOptionsError, m_taskName);
		break;
		
	case S_memLib_NOT_ENOUGH_MEMORY:
		wpi_setWPIErrorWithContext(TaskMemoryError, m_taskName);
		break;
		
	case S_taskLib_ILLEGAL_PRIORITY:
		wpi_setWPIErrorWithContext(TaskPriorityError, m_taskName);
		break;

	default:
		printErrno(errnoGet());
		wpi_setWPIErrorWithContext(TaskError, m_taskName);
	}
	return false;
	*/
}

